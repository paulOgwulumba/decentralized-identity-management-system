/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^2
 */
import * as algokit from '@algorandfoundation/algokit-utils';
import type {
  ABIAppCallArg,
  AppCallTransactionResult,
  AppCallTransactionResultOfType,
  AppCompilationResult,
  AppReference,
  AppState,
  CoreAppCallArgs,
  RawAppCallArgs,
  TealTemplateParams,
} from '@algorandfoundation/algokit-utils/types/app';
import type {
  AppClientCallCoreParams,
  AppClientCompilationParams,
  AppClientDeployCoreParams,
  AppDetails,
  ApplicationClient,
} from '@algorandfoundation/algokit-utils/types/app-client';
import type { AppSpec } from '@algorandfoundation/algokit-utils/types/app-spec';
import type {
  SendTransactionResult,
  TransactionToSign,
  SendTransactionFrom,
  SendTransactionParams,
} from '@algorandfoundation/algokit-utils/types/transaction';
import type { ABIResult, TransactionWithSigner } from 'algosdk';
import {
  Algodv2,
  OnApplicationComplete,
  Transaction,
  AtomicTransactionComposer,
  modelsv2,
} from 'algosdk';
export const APP_SPEC: AppSpec = {
  hints: {
    'startUpload(address,uint64,uint64,pay)void': {
      call_config: {
        no_op: 'CALL',
      },
    },
    'upload(address,uint64,uint64,byte[])void': {
      call_config: {
        no_op: 'CALL',
      },
    },
    'finishUpload(address)void': {
      call_config: {
        no_op: 'CALL',
      },
    },
    'startDelete(address)void': {
      call_config: {
        no_op: 'CALL',
      },
    },
    'deleteData(address,uint64)void': {
      call_config: {
        no_op: 'CALL',
      },
    },
    'updateApplication()void': {
      call_config: {
        update_application: 'CALL',
      },
    },
    'dummy()void': {
      call_config: {
        no_op: 'CALL',
      },
    },
    'createApplication()void': {
      call_config: {
        no_op: 'CREATE',
      },
    },
  },
  bare_call_config: {
    no_op: 'NEVER',
    opt_in: 'NEVER',
    close_out: 'NEVER',
    update_application: 'NEVER',
    delete_application: 'NEVER',
  },
  schema: {
    local: {
      declared: {},
      reserved: {},
    },
    global: {
      declared: {
        currentIndex: {
          type: 'uint64',
          key: 'currentIndex',
        },
      },
      reserved: {},
    },
  },
  state: {
    global: {
      num_byte_slices: 0,
      num_uints: 1,
    },
    local: {
      num_byte_slices: 0,
      num_uints: 0,
    },
  },
  source: {
    approval:
      'I3ByYWdtYSB2ZXJzaW9uIDEwCgovLyBUaGlzIFRFQUwgd2FzIGdlbmVyYXRlZCBieSBURUFMU2NyaXB0IHYwLjEwMy4wCi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGdvcmFuZGZvdW5kYXRpb24vVEVBTFNjcmlwdAoKLy8gVGhpcyBjb250cmFjdCBpcyBjb21wbGlhbnQgd2l0aCBhbmQvb3IgaW1wbGVtZW50cyB0aGUgZm9sbG93aW5nIEFSQ3M6IFsgQVJDNCBdCgovLyBUaGUgZm9sbG93aW5nIHRlbiBsaW5lcyBvZiBURUFMIGhhbmRsZSBpbml0aWFsIHByb2dyYW0gZmxvdwovLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCB0byBtYWtlIGl0IGVhc3kgZm9yIGFueW9uZSB0byBwYXJzZSB0aGUgc3RhcnQgb2YgdGhlIHByb2dyYW0gYW5kIGRldGVybWluZSBpZiBhIHNwZWNpZmljIGFjdGlvbiBpcyBhbGxvd2VkCi8vIEhlcmUsIGFjdGlvbiByZWZlcnMgdG8gdGhlIE9uQ29tcGxldGUgaW4gY29tYmluYXRpb24gd2l0aCB3aGV0aGVyIHRoZSBhcHAgaXMgYmVpbmcgY3JlYXRlZCBvciBjYWxsZWQKLy8gRXZlcnkgcG9zc2libGUgYWN0aW9uIGZvciB0aGlzIGNvbnRyYWN0IGlzIHJlcHJlc2VudGVkIGluIHRoZSBzd2l0Y2ggc3RhdGVtZW50Ci8vIElmIHRoZSBhY3Rpb24gaXMgbm90IGltcGxlbWVudGVkIGluIHRoZSBjb250cmFjdCwgaXRzIHJlc3BlY3RpdmUgYnJhbmNoIHdpbGwgYmUgIipOT1RfSU1QTEVNRU5URUQiIHdoaWNoIGp1c3QgY29udGFpbnMgImVyciIKdHhuIEFwcGxpY2F0aW9uSUQKIQppbnQgNgoqCnR4biBPbkNvbXBsZXRpb24KKwpzd2l0Y2ggKmNhbGxfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqY2FsbF9VcGRhdGVBcHBsaWNhdGlvbiAqTk9UX0lNUExFTUVOVEVEICpjcmVhdGVfTm9PcCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQgKk5PVF9JTVBMRU1FTlRFRCAqTk9UX0lNUExFTUVOVEVEICpOT1RfSU1QTEVNRU5URUQKCipOT1RfSU1QTEVNRU5URUQ6CgkvLyBUaGUgcmVxdWVzdGVkIGFjdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBjb250cmFjdC4gQXJlIHlvdSB1c2luZyB0aGUgY29ycmVjdCBPbkNvbXBsZXRlPyBEaWQgeW91IHNldCB5b3VyIGFwcCBJRD8KCWVycgoKLy8gc3RhcnRVcGxvYWQoYWRkcmVzcyx1aW50NjQsdWludDY0LHBheSl2b2lkCiphYmlfcm91dGVfc3RhcnRVcGxvYWQ6CgkvLyBtYnJQYXltZW50OiBwYXkKCXR4biBHcm91cEluZGV4CglpbnQgMQoJLQoJZHVwCglndHhucyBUeXBlRW51bQoJaW50IHBheQoJPT0KCgkvLyBhcmd1bWVudCAwIChtYnJQYXltZW50KSBmb3Igc3RhcnRVcGxvYWQgbXVzdCBiZSBhIHBheSB0cmFuc2FjdGlvbgoJYXNzZXJ0CgoJLy8gZW5kQm94U2l6ZTogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAzCglidG9pCgoJLy8gbnVtQm94ZXM6IHVpbnQ2NAoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgoJYnRvaQoKCS8vIHB1YktleTogYWRkcmVzcwoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQoJZHVwCglsZW4KCWludCAzMgoJPT0KCgkvLyBhcmd1bWVudCAzIChwdWJLZXkpIGZvciBzdGFydFVwbG9hZCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSBzdGFydFVwbG9hZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQscGF5KXZvaWQKCWNhbGxzdWIgc3RhcnRVcGxvYWQKCWludCAxCglyZXR1cm4KCi8vIHN0YXJ0VXBsb2FkKHB1YktleTogQWRkcmVzcywgbnVtQm94ZXM6IHVpbnQ2NCwgZW5kQm94U2l6ZTogdWludDY0LCBtYnJQYXltZW50OiBQYXlUeG4pOiB2b2lkCi8vCi8vCi8vIEFsbG9jYXRlIGJveGVzIHRvIGJlZ2luIGRhdGEgdXBsb2FkIHByb2Nlc3MKLy8KLy8gQHBhcmFtIHB1YktleSBUaGUgcHVia2V5IG9mIHRoZSBESUQKLy8gQHBhcmFtIG51bUJveGVzIFRoZSBudW1iZXIgb2YgYm94ZXMgdGhhdCB0aGUgZGF0YSB3aWxsIHRha2UgdXAKLy8gQHBhcmFtIGVuZEJveFNpemUgVGhlIHNpemUgb2YgdGhlIGxhc3QgYm94Ci8vIEBwYXJhbSBtYnJQYXltZW50IFBheW1lbnQgZnJvbSB0aGUgdXBsb2FkZXIgdG8gY292ZXIgdGhlIGJveCBNQlIKc3RhcnRVcGxvYWQ6Cglwcm90byA0IDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoJZHVwbiAzCgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czo2NAoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6NjYKCS8vIHN0YXJ0Qm94ID0gdGhpcy5jdXJyZW50SW5kZXgudmFsdWUKCWJ5dGUgMHg2Mzc1NzI3MjY1NmU3NDQ5NmU2NDY1NzggLy8gImN1cnJlbnRJbmRleCIKCWFwcF9nbG9iYWxfZ2V0CglmcmFtZV9idXJ5IDAgLy8gc3RhcnRCb3g6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6NjcKCS8vIGVuZEJveCA9IHN0YXJ0Qm94ICsgbnVtQm94ZXMgLSAxCglmcmFtZV9kaWcgMCAvLyBzdGFydEJveDogdWludDY0CglmcmFtZV9kaWcgLTIgLy8gbnVtQm94ZXM6IHVpbnQ2NAoJKwoJaW50IDEKCS0KCWZyYW1lX2J1cnkgMSAvLyBlbmRCb3g6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6NjkKCS8vIG1ldGFkYXRhOiBNZXRhZGF0YSA9IHsKCS8vICAgICAgIHN0YXJ0OiBzdGFydEJveCwKCS8vICAgICAgIGVuZDogZW5kQm94LAoJLy8gICAgICAgc3RhdHVzOiAwLCAvLyBVUExPQURJTkcsCgkvLyAgICAgICBlbmRTaXplOiBlbmRCb3hTaXplLAoJLy8gICAgICAgbGFzdERlbGV0ZWQ6IDAsCgkvLyAgICAgfQoJZnJhbWVfZGlnIDAgLy8gc3RhcnRCb3g6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIDEgLy8gZW5kQm94OiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDAwCgljb25jYXQKCWZyYW1lX2RpZyAtMyAvLyBlbmRCb3hTaXplOiB1aW50NjQKCWl0b2IKCWNvbmNhdAoJYnl0ZSAweDAwMDAwMDAwMDAwMDAwMDAKCWNvbmNhdAoJZnJhbWVfYnVyeSAyIC8vIG1ldGFkYXRhOiBNZXRhZGF0YQoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6NzcKCS8vIGFzc2VydCghdGhpcy5tZXRhZGF0YShwdWJLZXkpLmV4aXN0cykKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWJveF9sZW4KCXN3YXAKCXBvcAoJIQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czo3OQoJLy8gdGhpcy5tZXRhZGF0YShwdWJLZXkpLnZhbHVlID0gbWV0YWRhdGEKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWZyYW1lX2RpZyAyIC8vIG1ldGFkYXRhOiBNZXRhZGF0YQoJYm94X3B1dAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6ODEKCS8vIHRoaXMuY3VycmVudEluZGV4LnZhbHVlID0gZW5kQm94ICsgMQoJYnl0ZSAweDYzNzU3MjcyNjU2ZTc0NDk2ZTY0NjU3OCAvLyAiY3VycmVudEluZGV4IgoJZnJhbWVfZGlnIDEgLy8gZW5kQm94OiB1aW50NjQKCWludCAxCgkrCglhcHBfZ2xvYmFsX3B1dAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6ODMKCS8vIHRvdGFsQ29zdCA9IG51bUJveGVzICogQ09TVF9QRVJfQk9YICsgLy8gY29zdCBvZiBkYXRhIGJveGVzCgkvLyAgICAgICAobnVtQm94ZXMgLSAxKSAqIE1BWF9CT1hfU0laRSAqIENPU1RfUEVSX0JZVEUgKyAvLyBjb3N0IG9mIGRhdGEKCS8vICAgICAgIG51bUJveGVzICogOCAqIENPU1RfUEVSX0JZVEUgKyAvLyBjb3N0IG9mIGRhdGEga2V5cwoJLy8gICAgICAgZW5kQm94U2l6ZSAqIENPU1RfUEVSX0JZVEUgKyAvLyBjb3N0IG9mIGxhc3QgZGF0YSBib3gKCS8vICAgICAgIENPU1RfUEVSX0JPWCArCgkvLyAgICAgICAoOCArIDggKyAxICsgOCArIDMyICsgOCkgKiBDT1NUX1BFUl9CWVRFCglmcmFtZV9kaWcgLTIgLy8gbnVtQm94ZXM6IHVpbnQ2NAoJaW50IDI1MDAKCSoKCWZyYW1lX2RpZyAtMiAvLyBudW1Cb3hlczogdWludDY0CglpbnQgMQoJLQoJaW50IDMyNzY4CgkqCglpbnQgNDAwCgkqCgkrCglmcmFtZV9kaWcgLTIgLy8gbnVtQm94ZXM6IHVpbnQ2NAoJaW50IDgKCSoKCWludCA0MDAKCSoKCSsKCWZyYW1lX2RpZyAtMyAvLyBlbmRCb3hTaXplOiB1aW50NjQKCWludCA0MDAKCSoKCSsKCWludCAyNTAwCgkrCglpbnQgMjYwMDAKCSsKCWZyYW1lX2J1cnkgMyAvLyB0b3RhbENvc3Q6IHVpbnQ2NAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6OTAKCS8vIGFzc2VydChtYnJQYXltZW50LmFtb3VudCA9PT0gdG90YWxDb3N0KQoJZnJhbWVfZGlnIC00IC8vIG1iclBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgQW1vdW50CglmcmFtZV9kaWcgMyAvLyB0b3RhbENvc3Q6IHVpbnQ2NAoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6OTEKCS8vIGFzc2VydChtYnJQYXltZW50LnJlY2VpdmVyID09PSB0aGlzLmFwcC5hZGRyZXNzKQoJZnJhbWVfZGlnIC00IC8vIG1iclBheW1lbnQ6IFBheVR4bgoJZ3R4bnMgUmVjZWl2ZXIKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCgk9PQoJYXNzZXJ0CglyZXRzdWIKCi8vIHVwbG9hZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYnl0ZVtdKXZvaWQKKmFiaV9yb3V0ZV91cGxvYWQ6CgkvLyBkYXRhOiBieXRlW10KCXR4bmEgQXBwbGljYXRpb25BcmdzIDQKCWV4dHJhY3QgMiAwCgoJLy8gb2Zmc2V0OiB1aW50NjQKCXR4bmEgQXBwbGljYXRpb25BcmdzIDMKCWJ0b2kKCgkvLyBib3hJbmRleDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gcHViS2V5OiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDMgKHB1YktleSkgZm9yIHVwbG9hZCBtdXN0IGJlIGEgYWRkcmVzcwoJYXNzZXJ0CgoJLy8gZXhlY3V0ZSB1cGxvYWQoYWRkcmVzcyx1aW50NjQsdWludDY0LGJ5dGVbXSl2b2lkCgljYWxsc3ViIHVwbG9hZAoJaW50IDEKCXJldHVybgoKLy8gdXBsb2FkKHB1YktleTogQWRkcmVzcywgYm94SW5kZXg6IHVpbnQ2NCwgb2Zmc2V0OiB1aW50NjQsIGRhdGE6IGJ5dGVzKTogdm9pZAovLwovLwovLyBVcGxvYWQgZGF0YSB0byBhIHNwZWNpZmljIG9mZnNldCBpbiBhIGJveAovLwovLyBAcGFyYW0gcHViS2V5IFRoZSBwdWJrZXkgb2YgdGhlIERJRAovLyBAcGFyYW0gYm94SW5kZXggVGhlIGluZGV4IG9mIHRoZSBib3ggdG8gdXBsb2FkIHRoZSBnaXZlbiBjaHVuayBvZiBkYXRhIHRvCi8vIEBwYXJhbSBvZmZzZXQgVGhlIG9mZnNldCB3aXRoaW4gdGhlIGJveCB0byBzdGFydCB3cml0aW5nIHRoZSBkYXRhCi8vIEBwYXJhbSBkYXRhIFRoZSBkYXRhIHRvIHdyaXRlCnVwbG9hZDoKCXByb3RvIDQgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxMDQKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjEwNgoJLy8gbWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhKHB1YktleSkudmFsdWUKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWZyYW1lX2J1cnkgMCAvLyBzdG9yYWdlIGtleS8vbWV0YWRhdGEKCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjEwNwoJLy8gYXNzZXJ0KG1ldGFkYXRhLnN0YXR1cyA9PT0gMCkKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWludCAxNiAvLyBoZWFkT2Zmc2V0CglpbnQgMQoJYm94X2V4dHJhY3QKCWJ0b2kKCWludCAwCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxMDgKCS8vIGFzc2VydChtZXRhZGF0YS5zdGFydCA8PSBib3hJbmRleCAmJiBib3hJbmRleCA8PSBtZXRhZGF0YS5lbmQpCglmcmFtZV9kaWcgLTEgLy8gcHViS2V5OiBBZGRyZXNzCglpbnQgMAoJaW50IDgKCWJveF9leHRyYWN0CglidG9pCglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQ2NAoJPD0KCWR1cAoJYnogKnNraXBfYW5kMAoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWludCA4IC8vIGhlYWRPZmZzZXQKCWludCA4Cglib3hfZXh0cmFjdAoJYnRvaQoJPD0KCSYmCgoqc2tpcF9hbmQwOgoJYXNzZXJ0CgoJLy8gKmlmMF9jb25kaXRpb24KCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6MTEwCgkvLyBvZmZzZXQgPT09IDAKCWZyYW1lX2RpZyAtMyAvLyBvZmZzZXQ6IHVpbnQ2NAoJaW50IDAKCT09CglieiAqaWYwX2VuZAoKCS8vICppZjBfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxMTEKCS8vIHRoaXMuZGF0YUJveGVzKGJveEluZGV4KS5jcmVhdGUoCgkvLyAgICAgICAgIGJveEluZGV4ID09PSBtZXRhZGF0YS5lbmQgPyBtZXRhZGF0YS5lbmRTaXplIDogTUFYX0JPWF9TSVpFLAoJLy8gICAgICAgKQoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50NjQKCWl0b2IKCWZyYW1lX2RpZyAtMiAvLyBib3hJbmRleDogdWludDY0CglmcmFtZV9kaWcgLTEgLy8gcHViS2V5OiBBZGRyZXNzCglpbnQgOCAvLyBoZWFkT2Zmc2V0CglpbnQgOAoJYm94X2V4dHJhY3QKCWJ0b2kKCT09CglieiAqdGVybmFyeTBfZmFsc2UKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWludCAxNyAvLyBoZWFkT2Zmc2V0CglpbnQgOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWIgKnRlcm5hcnkwX2VuZAoKKnRlcm5hcnkwX2ZhbHNlOgoJaW50IDMyNzY4CgoqdGVybmFyeTBfZW5kOgoJYm94X2NyZWF0ZQoJcG9wCgoqaWYwX2VuZDoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6MTE2CgkvLyB0aGlzLmRhdGFCb3hlcyhib3hJbmRleCkucmVwbGFjZShvZmZzZXQsIGRhdGEpCglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIC0zIC8vIG9mZnNldDogdWludDY0CglmcmFtZV9kaWcgLTQgLy8gZGF0YTogYnl0ZXMKCWJveF9yZXBsYWNlCglyZXRzdWIKCi8vIGZpbmlzaFVwbG9hZChhZGRyZXNzKXZvaWQKKmFiaV9yb3V0ZV9maW5pc2hVcGxvYWQ6CgkvLyBwdWJLZXk6IGFkZHJlc3MKCXR4bmEgQXBwbGljYXRpb25BcmdzIDEKCWR1cAoJbGVuCglpbnQgMzIKCT09CgoJLy8gYXJndW1lbnQgMCAocHViS2V5KSBmb3IgZmluaXNoVXBsb2FkIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIGZpbmlzaFVwbG9hZChhZGRyZXNzKXZvaWQKCWNhbGxzdWIgZmluaXNoVXBsb2FkCglpbnQgMQoJcmV0dXJuCgovLyBmaW5pc2hVcGxvYWQocHViS2V5OiBBZGRyZXNzKTogdm9pZAovLwovLwovLyBNYXJrIHVwbG9hZGluZyBhcyBmYWxzZQovLwovLyBAcGFyYW0gcHViS2V5IFRoZSBhZGRyZXNzIG9mIHRoZSBESUQKZmluaXNoVXBsb2FkOgoJcHJvdG8gMSAwCgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxMjYKCS8vIGFzc2VydCh0aGlzLnR4bi5zZW5kZXIgPT09IGdsb2JhbHMuY3JlYXRvckFkZHJlc3MpCgl0eG4gU2VuZGVyCglnbG9iYWwgQ3JlYXRvckFkZHJlc3MKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjEyOAoJLy8gdGhpcy5tZXRhZGF0YShwdWJLZXkpLnZhbHVlLnN0YXR1cyA9IDEKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWludCAxNiAvLyBoZWFkT2Zmc2V0CglieXRlIDB4MDEKCWJveF9yZXBsYWNlCglyZXRzdWIKCi8vIHN0YXJ0RGVsZXRlKGFkZHJlc3Mpdm9pZAoqYWJpX3JvdXRlX3N0YXJ0RGVsZXRlOgoJLy8gcHViS2V5OiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDAgKHB1YktleSkgZm9yIHN0YXJ0RGVsZXRlIG11c3QgYmUgYSBhZGRyZXNzCglhc3NlcnQKCgkvLyBleGVjdXRlIHN0YXJ0RGVsZXRlKGFkZHJlc3Mpdm9pZAoJY2FsbHN1YiBzdGFydERlbGV0ZQoJaW50IDEKCXJldHVybgoKLy8gc3RhcnREZWxldGUocHViS2V5OiBBZGRyZXNzKTogdm9pZAovLwovLyBTdGFydHMgdGhlIGRlbGV0aW9uIHByb2Nlc3MgZm9yIHRoZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIERJRAovLwovLyBAcGFyYW0gcHViS2V5IFRoZSBhZGRyZXNzIG9mIHRoZSBESUQKc3RhcnREZWxldGU6Cglwcm90byAxIDAKCgkvLyBQdXNoIGVtcHR5IGJ5dGVzIGFmdGVyIHRoZSBmcmFtZSBwb2ludGVyIHRvIHJlc2VydmUgc3BhY2UgZm9yIGxvY2FsIHZhcmlhYmxlcwoJYnl0ZSAweAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6MTM3CgkvLyBhc3NlcnQodGhpcy50eG4uc2VuZGVyID09PSBnbG9iYWxzLmNyZWF0b3JBZGRyZXNzKQoJdHhuIFNlbmRlcgoJZ2xvYmFsIENyZWF0b3JBZGRyZXNzCgk9PQoJYXNzZXJ0CgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxMzkKCS8vIG1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YShwdWJLZXkpLnZhbHVlCglmcmFtZV9kaWcgLTEgLy8gcHViS2V5OiBBZGRyZXNzCglmcmFtZV9idXJ5IDAgLy8gc3RvcmFnZSBrZXkvL21ldGFkYXRhCgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxNDAKCS8vIGFzc2VydChtZXRhZGF0YS5zdGF0dXMgPT09IDEpCglmcmFtZV9kaWcgLTEgLy8gcHViS2V5OiBBZGRyZXNzCglpbnQgMTYgLy8gaGVhZE9mZnNldAoJaW50IDEKCWJveF9leHRyYWN0CglidG9pCglpbnQgMQoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6MTQyCgkvLyBtZXRhZGF0YS5zdGF0dXMgPSAyCglmcmFtZV9kaWcgMCAvLyBzdG9yYWdlIGtleS8vbWV0YWRhdGEKCWludCAxNiAvLyBoZWFkT2Zmc2V0CglieXRlIDB4MDIKCWJveF9yZXBsYWNlCglyZXRzdWIKCi8vIGRlbGV0ZURhdGEoYWRkcmVzcyx1aW50NjQpdm9pZAoqYWJpX3JvdXRlX2RlbGV0ZURhdGE6CgkvLyBib3hJbmRleDogdWludDY0Cgl0eG5hIEFwcGxpY2F0aW9uQXJncyAyCglidG9pCgoJLy8gcHViS2V5OiBhZGRyZXNzCgl0eG5hIEFwcGxpY2F0aW9uQXJncyAxCglkdXAKCWxlbgoJaW50IDMyCgk9PQoKCS8vIGFyZ3VtZW50IDEgKHB1YktleSkgZm9yIGRlbGV0ZURhdGEgbXVzdCBiZSBhIGFkZHJlc3MKCWFzc2VydAoKCS8vIGV4ZWN1dGUgZGVsZXRlRGF0YShhZGRyZXNzLHVpbnQ2NCl2b2lkCgljYWxsc3ViIGRlbGV0ZURhdGEKCWludCAxCglyZXR1cm4KCi8vIGRlbGV0ZURhdGEocHViS2V5OiBBZGRyZXNzLCBib3hJbmRleDogdWludDY0KTogdm9pZAovLwovLyBEZWxldGVzIGEgYm94IG9mIGRhdGEKLy8KLy8gQHBhcmFtIHB1YktleSBUaGUgYWRkcmVzcyBvZiB0aGUgRElECi8vIEBwYXJhbSBib3hJbmRleCBUaGUgaW5kZXggb2YgdGhlIGJveCB0byBkZWxldGUKZGVsZXRlRGF0YToKCXByb3RvIDIgMAoKCS8vIFB1c2ggZW1wdHkgYnl0ZXMgYWZ0ZXIgdGhlIGZyYW1lIHBvaW50ZXIgdG8gcmVzZXJ2ZSBzcGFjZSBmb3IgbG9jYWwgdmFyaWFibGVzCglieXRlIDB4CglkdXAKCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjE1MgoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6MTU0CgkvLyBtZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEocHViS2V5KS52YWx1ZQoJZnJhbWVfZGlnIC0xIC8vIHB1YktleTogQWRkcmVzcwoJZnJhbWVfYnVyeSAwIC8vIHN0b3JhZ2Uga2V5Ly9tZXRhZGF0YQoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6MTU1CgkvLyBhc3NlcnQobWV0YWRhdGEuc3RhdHVzID09PSAyKQoJZnJhbWVfZGlnIC0xIC8vIHB1YktleTogQWRkcmVzcwoJaW50IDE2IC8vIGhlYWRPZmZzZXQKCWludCAxCglib3hfZXh0cmFjdAoJYnRvaQoJaW50IDIKCT09Cglhc3NlcnQKCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjE1NgoJLy8gYXNzZXJ0KG1ldGFkYXRhLnN0YXJ0IDw9IGJveEluZGV4ICYmIGJveEluZGV4IDw9IG1ldGFkYXRhLmVuZCkKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWludCAwCglpbnQgOAoJYm94X2V4dHJhY3QKCWJ0b2kKCWZyYW1lX2RpZyAtMiAvLyBib3hJbmRleDogdWludDY0Cgk8PQoJZHVwCglieiAqc2tpcF9hbmQxCglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQ2NAoJZnJhbWVfZGlnIC0xIC8vIHB1YktleTogQWRkcmVzcwoJaW50IDggLy8gaGVhZE9mZnNldAoJaW50IDgKCWJveF9leHRyYWN0CglidG9pCgk8PQoJJiYKCipza2lwX2FuZDE6Cglhc3NlcnQKCgkvLyAqaWYxX2NvbmRpdGlvbgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxNTgKCS8vIGJveEluZGV4ICE9PSBtZXRhZGF0YS5zdGFydAoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWludCAwCglpbnQgOAoJYm94X2V4dHJhY3QKCWJ0b2kKCSE9CglieiAqaWYxX2VuZAoKCS8vICppZjFfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxNTkKCS8vIGFzc2VydChtZXRhZGF0YS5sYXN0RGVsZXRlZCA9PT0gYm94SW5kZXggLSAxKQoJZnJhbWVfZGlnIC0xIC8vIHB1YktleTogQWRkcmVzcwoJaW50IDI1IC8vIGhlYWRPZmZzZXQKCWludCA4Cglib3hfZXh0cmFjdAoJYnRvaQoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50NjQKCWludCAxCgktCgk9PQoJYXNzZXJ0CgoqaWYxX2VuZDoKCS8vIGNvbnRyYWN0cy9BbGdvRElELmFsZ28udHM6MTYyCgkvLyBwcmVNQlIgPSBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MubWluQmFsYW5jZQoJZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKCWFjY3RfcGFyYW1zX2dldCBBY2N0TWluQmFsYW5jZQoJcG9wCglmcmFtZV9idXJ5IDEgLy8gcHJlTUJSOiB1aW50NjQKCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjE2NAoJLy8gdGhpcy5kYXRhQm94ZXMoYm94SW5kZXgpLmRlbGV0ZSgpCglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQ2NAoJaXRvYgoJYm94X2RlbAoKCS8vICppZjJfY29uZGl0aW9uCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjE2NgoJLy8gYm94SW5kZXggPT09IG1ldGFkYXRhLmVuZAoJZnJhbWVfZGlnIC0yIC8vIGJveEluZGV4OiB1aW50NjQKCWZyYW1lX2RpZyAtMSAvLyBwdWJLZXk6IEFkZHJlc3MKCWludCA4IC8vIGhlYWRPZmZzZXQKCWludCA4Cglib3hfZXh0cmFjdAoJYnRvaQoJPT0KCWJ6ICppZjJfZWxzZQoKCS8vICppZjJfY29uc2VxdWVudAoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxNjYKCS8vIHRoaXMubWV0YWRhdGEocHViS2V5KS5kZWxldGUoKQoJZnJhbWVfZGlnIC0xIC8vIHB1YktleTogQWRkcmVzcwoJYm94X2RlbAoJYiAqaWYyX2VuZAoKKmlmMl9lbHNlOgoJLy8gY29udHJhY3RzL0FsZ29ESUQuYWxnby50czoxNjcKCS8vIG1ldGFkYXRhLmxhc3REZWxldGVkID0gYm94SW5kZXgKCWludCAyNSAvLyBoZWFkT2Zmc2V0CglmcmFtZV9kaWcgLTIgLy8gYm94SW5kZXg6IHVpbnQ2NAoJaXRvYgoJZnJhbWVfZGlnIDAgLy8gc3RvcmFnZSBrZXkvL21ldGFkYXRhCgljb3ZlciAyCglib3hfcmVwbGFjZQoKKmlmMl9lbmQ6CgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjE2OQoJLy8gc2VuZFBheW1lbnQoewoJLy8gICAgICAgYW1vdW50OiBwcmVNQlIgLSBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MubWluQmFsYW5jZSwKCS8vICAgICAgIHJlY2VpdmVyOiB0aGlzLnR4bi5zZW5kZXIsCgkvLyAgICAgfSkKCWl0eG5fYmVnaW4KCWludCBwYXkKCWl0eG5fZmllbGQgVHlwZUVudW0KCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjE3MAoJLy8gYW1vdW50OiBwcmVNQlIgLSBnbG9iYWxzLmN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MubWluQmFsYW5jZQoJZnJhbWVfZGlnIDEgLy8gcHJlTUJSOiB1aW50NjQKCWdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCglhY2N0X3BhcmFtc19nZXQgQWNjdE1pbkJhbGFuY2UKCXBvcAoJLQoJaXR4bl9maWVsZCBBbW91bnQKCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjE3MQoJLy8gcmVjZWl2ZXI6IHRoaXMudHhuLnNlbmRlcgoJdHhuIFNlbmRlcgoJaXR4bl9maWVsZCBSZWNlaXZlcgoKCS8vIEZlZSBmaWVsZCBub3Qgc2V0LCBkZWZhdWx0aW5nIHRvIDAKCWludCAwCglpdHhuX2ZpZWxkIEZlZQoKCS8vIFN1Ym1pdCBpbm5lciB0cmFuc2FjdGlvbgoJaXR4bl9zdWJtaXQKCXJldHN1YgoKLy8gdXBkYXRlQXBwbGljYXRpb24oKXZvaWQKKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbjoKCS8vIGV4ZWN1dGUgdXBkYXRlQXBwbGljYXRpb24oKXZvaWQKCWNhbGxzdWIgdXBkYXRlQXBwbGljYXRpb24KCWludCAxCglyZXR1cm4KCi8vIHVwZGF0ZUFwcGxpY2F0aW9uKCk6IHZvaWQKLy8KLy8gQWxsb3cgdGhlIGNvbnRyYWN0IHRvIGJlIHVwZGF0ZWQgYnkgdGhlIGNyZWF0b3IKdXBkYXRlQXBwbGljYXRpb246Cglwcm90byAwIDAKCgkvLyBjb250cmFjdHMvQWxnb0RJRC5hbGdvLnRzOjE3OQoJLy8gYXNzZXJ0KHRoaXMudHhuLnNlbmRlciA9PT0gZ2xvYmFscy5jcmVhdG9yQWRkcmVzcykKCXR4biBTZW5kZXIKCWdsb2JhbCBDcmVhdG9yQWRkcmVzcwoJPT0KCWFzc2VydAoJcmV0c3ViCgovLyBkdW1teSgpdm9pZAoqYWJpX3JvdXRlX2R1bW15OgoJLy8gZXhlY3V0ZSBkdW1teSgpdm9pZAoJY2FsbHN1YiBkdW1teQoJaW50IDEKCXJldHVybgoKLy8gZHVtbXkoKTogdm9pZAovLwovLyBEdW1teSBmdW5jdGlvbiB0byBhZGQgZXh0cmEgYm94IHJlZmVyZW5jZXMgZm9yIGRlbGV0ZURhdGEuCi8vIEJveGVzIGFyZSAzMmssIGJ1dCBhIHNpbmdsZSBhcHAgY2FsbCBjYW4gb25seSBpbmNsdWRlIGVub3VnaCByZWZlcmVuY2VzIHRvIHJlYWQvd3JpdGUgOGsKLy8gYXQgYSB0aW1lLiBUaHVzIHdoZW4gYSBib3ggaXMgZGVsZXRlZCwgd2UgbmVlZCB0byBhZGQgYWRkaXRpb25hbCBkdW1teSBjYWxscyB3aXRoIGJveAovLyByZWZlcmVuY2VzIHRvIGluY3JlYXNlIHRoZSB0b3RhbCByZWFkL3dyaXRlIGJ1ZGdldCB0byAzMmsuCmR1bW15OgoJcHJvdG8gMCAwCglyZXRzdWIKCiphYmlfcm91dGVfY3JlYXRlQXBwbGljYXRpb246CglpbnQgMQoJcmV0dXJuCgoqY3JlYXRlX05vT3A6CgltZXRob2QgImNyZWF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV9jcmVhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjcmVhdGUgTm9PcAoJZXJyCgoqY2FsbF9Ob09wOgoJbWV0aG9kICJzdGFydFVwbG9hZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQscGF5KXZvaWQiCgltZXRob2QgInVwbG9hZChhZGRyZXNzLHVpbnQ2NCx1aW50NjQsYnl0ZVtdKXZvaWQiCgltZXRob2QgImZpbmlzaFVwbG9hZChhZGRyZXNzKXZvaWQiCgltZXRob2QgInN0YXJ0RGVsZXRlKGFkZHJlc3Mpdm9pZCIKCW1ldGhvZCAiZGVsZXRlRGF0YShhZGRyZXNzLHVpbnQ2NCl2b2lkIgoJbWV0aG9kICJkdW1teSgpdm9pZCIKCXR4bmEgQXBwbGljYXRpb25BcmdzIDAKCW1hdGNoICphYmlfcm91dGVfc3RhcnRVcGxvYWQgKmFiaV9yb3V0ZV91cGxvYWQgKmFiaV9yb3V0ZV9maW5pc2hVcGxvYWQgKmFiaV9yb3V0ZV9zdGFydERlbGV0ZSAqYWJpX3JvdXRlX2RlbGV0ZURhdGEgKmFiaV9yb3V0ZV9kdW1teQoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjYWxsIE5vT3AKCWVycgoKKmNhbGxfVXBkYXRlQXBwbGljYXRpb246CgltZXRob2QgInVwZGF0ZUFwcGxpY2F0aW9uKCl2b2lkIgoJdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMAoJbWF0Y2ggKmFiaV9yb3V0ZV91cGRhdGVBcHBsaWNhdGlvbgoKCS8vIHRoaXMgY29udHJhY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBnaXZlbiBBQkkgbWV0aG9kIGZvciBjYWxsIFVwZGF0ZUFwcGxpY2F0aW9uCgllcnI=',
    clear: 'I3ByYWdtYSB2ZXJzaW9uIDEw',
  },
  contract: {
    name: 'AlgoDID',
    desc: '',
    methods: [
      {
        name: 'startUpload',
        desc: 'Allocate boxes to begin data upload process',
        args: [
          {
            name: 'pubKey',
            type: 'address',
            desc: 'The pubkey of the DID',
          },
          {
            name: 'numBoxes',
            type: 'uint64',
            desc: 'The number of boxes that the data will take up',
          },
          {
            name: 'endBoxSize',
            type: 'uint64',
            desc: 'The size of the last box',
          },
          {
            name: 'mbrPayment',
            type: 'pay',
            desc: 'Payment from the uploader to cover the box MBR',
          },
        ],
        returns: {
          type: 'void',
        },
      },
      {
        name: 'upload',
        desc: 'Upload data to a specific offset in a box',
        args: [
          {
            name: 'pubKey',
            type: 'address',
            desc: 'The pubkey of the DID',
          },
          {
            name: 'boxIndex',
            type: 'uint64',
            desc: 'The index of the box to upload the given chunk of data to',
          },
          {
            name: 'offset',
            type: 'uint64',
            desc: 'The offset within the box to start writing the data',
          },
          {
            name: 'data',
            type: 'byte[]',
            desc: 'The data to write',
          },
        ],
        returns: {
          type: 'void',
        },
      },
      {
        name: 'finishUpload',
        desc: 'Mark uploading as false',
        args: [
          {
            name: 'pubKey',
            type: 'address',
            desc: 'The address of the DID',
          },
        ],
        returns: {
          type: 'void',
        },
      },
      {
        name: 'startDelete',
        desc: 'Starts the deletion process for the data associated with a DID',
        args: [
          {
            name: 'pubKey',
            type: 'address',
            desc: 'The address of the DID',
          },
        ],
        returns: {
          type: 'void',
        },
      },
      {
        name: 'deleteData',
        desc: 'Deletes a box of data',
        args: [
          {
            name: 'pubKey',
            type: 'address',
            desc: 'The address of the DID',
          },
          {
            name: 'boxIndex',
            type: 'uint64',
            desc: 'The index of the box to delete',
          },
        ],
        returns: {
          type: 'void',
        },
      },
      {
        name: 'updateApplication',
        desc: 'Allow the contract to be updated by the creator',
        args: [],
        returns: {
          type: 'void',
        },
      },
      {
        name: 'dummy',
        desc: 'Dummy function to add extra box references for deleteData.\nBoxes are 32k, but a single app call can only include enough references to read/write 8k\nat a time. Thus when a box is deleted, we need to add additional dummy calls with box\nreferences to increase the total read/write budget to 32k.',
        args: [],
        returns: {
          type: 'void',
        },
      },
      {
        name: 'createApplication',
        args: [],
        returns: {
          type: 'void',
        },
      },
    ],
  },
};

/**
 * Defines an onCompletionAction of 'no_op'
 */
export type OnCompleteNoOp = { onCompleteAction?: 'no_op' | OnApplicationComplete.NoOpOC };
/**
 * Defines an onCompletionAction of 'opt_in'
 */
export type OnCompleteOptIn = { onCompleteAction: 'opt_in' | OnApplicationComplete.OptInOC };
/**
 * Defines an onCompletionAction of 'close_out'
 */
export type OnCompleteCloseOut = {
  onCompleteAction: 'close_out' | OnApplicationComplete.CloseOutOC;
};
/**
 * Defines an onCompletionAction of 'delete_application'
 */
export type OnCompleteDelApp = {
  onCompleteAction: 'delete_application' | OnApplicationComplete.DeleteApplicationOC;
};
/**
 * Defines an onCompletionAction of 'update_application'
 */
export type OnCompleteUpdApp = {
  onCompleteAction: 'update_application' | OnApplicationComplete.UpdateApplicationOC;
};
/**
 * A state record containing a single unsigned integer
 */
export type IntegerState = {
  /**
   * Gets the state value as a BigInt.
   */
  asBigInt(): bigint;
  /**
   * Gets the state value as a number.
   */
  asNumber(): number;
};
/**
 * A state record containing binary data
 */
export type BinaryState = {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array;
  /**
   * Gets the state value as a string
   */
  asString(): string;
};

export type AppCreateCallTransactionResult = AppCallTransactionResult &
  Partial<AppCompilationResult> &
  AppReference;
export type AppUpdateCallTransactionResult = AppCallTransactionResult &
  Partial<AppCompilationResult>;

export type AppClientComposeCallCoreParams = Omit<AppClientCallCoreParams, 'sendParams'> & {
  sendParams?: Omit<
    SendTransactionParams,
    | 'skipSending'
    | 'atc'
    | 'skipWaiting'
    | 'maxRoundsToWaitForConfirmation'
    | 'populateAppCallResources'
  >;
};
export type AppClientComposeExecuteParams = Pick<
  SendTransactionParams,
  'skipWaiting' | 'maxRoundsToWaitForConfirmation' | 'populateAppCallResources' | 'suppressLog'
>;

/**
 * Defines the types of available calls and state of the AlgoDid smart contract.
 */
export type AlgoDid = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods: Record<
    'startUpload(address,uint64,uint64,pay)void' | 'startUpload',
    {
      argsObj: {
        /**
         * The pubkey of the DID
         */
        pubKey: string;
        /**
         * The number of boxes that the data will take up
         */
        numBoxes: bigint | number;
        /**
         * The size of the last box
         */
        endBoxSize: bigint | number;
        /**
         * Payment from the uploader to cover the box MBR
         */
        mbrPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>;
      };
      argsTuple: [
        pubKey: string,
        numBoxes: bigint | number,
        endBoxSize: bigint | number,
        mbrPayment: TransactionToSign | Transaction | Promise<SendTransactionResult>,
      ];
      returns: void;
    }
  > &
    Record<
      'upload(address,uint64,uint64,byte[])void' | 'upload',
      {
        argsObj: {
          /**
           * The pubkey of the DID
           */
          pubKey: string;
          /**
           * The index of the box to upload the given chunk of data to
           */
          boxIndex: bigint | number;
          /**
           * The offset within the box to start writing the data
           */
          offset: bigint | number;
          /**
           * The data to write
           */
          data: Uint8Array;
        };
        argsTuple: [
          pubKey: string,
          boxIndex: bigint | number,
          offset: bigint | number,
          data: Uint8Array,
        ];
        returns: void;
      }
    > &
    Record<
      'finishUpload(address)void' | 'finishUpload',
      {
        argsObj: {
          /**
           * The address of the DID
           */
          pubKey: string;
        };
        argsTuple: [pubKey: string];
        returns: void;
      }
    > &
    Record<
      'startDelete(address)void' | 'startDelete',
      {
        argsObj: {
          /**
           * The address of the DID
           */
          pubKey: string;
        };
        argsTuple: [pubKey: string];
        returns: void;
      }
    > &
    Record<
      'deleteData(address,uint64)void' | 'deleteData',
      {
        argsObj: {
          /**
           * The address of the DID
           */
          pubKey: string;
          /**
           * The index of the box to delete
           */
          boxIndex: bigint | number;
        };
        argsTuple: [pubKey: string, boxIndex: bigint | number];
        returns: void;
      }
    > &
    Record<
      'updateApplication()void' | 'updateApplication',
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      'dummy()void' | 'dummy',
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    > &
    Record<
      'createApplication()void' | 'createApplication',
      {
        argsObj: {};
        argsTuple: [];
        returns: void;
      }
    >;
  /**
   * Defines the shape of the global and local state of the application.
   */
  state: {
    global: {
      currentIndex?: IntegerState;
    };
  };
};
/**
 * Defines the possible abi call signatures
 */
export type AlgoDidSig = keyof AlgoDid['methods'];
/**
 * Defines an object containing all relevant parameters for a single call to the contract. Where TSignature is undefined, a bare call is made
 */
export type TypedCallParams<TSignature extends AlgoDidSig | undefined> = {
  method: TSignature;
  methodArgs: TSignature extends undefined ? undefined : Array<ABIAppCallArg | undefined>;
} & AppClientCallCoreParams &
  CoreAppCallArgs;
/**
 * Defines the arguments required for a bare call
 */
export type BareCallArgs = Omit<RawAppCallArgs, keyof CoreAppCallArgs>;
/**
 * Maps a method signature from the AlgoDid smart contract to the method's arguments in either tuple of struct form
 */
export type MethodArgs<TSignature extends AlgoDidSig> = AlgoDid['methods'][TSignature][
  | 'argsObj'
  | 'argsTuple'];
/**
 * Maps a method signature from the AlgoDid smart contract to the method's return type
 */
export type MethodReturn<TSignature extends AlgoDidSig> = AlgoDid['methods'][TSignature]['returns'];

/**
 * A factory for available 'create' calls
 */
export type AlgoDidCreateCalls = (typeof AlgoDidCallFactory)['create'];
/**
 * Defines supported create methods for this smart contract
 */
export type AlgoDidCreateCallParams = TypedCallParams<'createApplication()void'> & OnCompleteNoOp;
/**
 * A factory for available 'update' calls
 */
export type AlgoDidUpdateCalls = (typeof AlgoDidCallFactory)['update'];
/**
 * Defines supported update methods for this smart contract
 */
export type AlgoDidUpdateCallParams = TypedCallParams<'updateApplication()void'>;
/**
 * Defines arguments required for the deploy method.
 */
export type AlgoDidDeployArgs = {
  deployTimeParams?: TealTemplateParams;
  /**
   * A delegate which takes a create call factory and returns the create call params for this smart contract
   */
  createCall?: (callFactory: AlgoDidCreateCalls) => AlgoDidCreateCallParams;
  /**
   * A delegate which takes a update call factory and returns the update call params for this smart contract
   */
  updateCall?: (callFactory: AlgoDidUpdateCalls) => AlgoDidUpdateCallParams;
};

/**
 * Exposes methods for constructing all available smart contract calls
 */
export abstract class AlgoDidCallFactory {
  /**
   * Gets available create call factories
   */
  static get create() {
    return {
      /**
       * Constructs a create call for the AlgoDID smart contract using the createApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      createApplication(
        args: MethodArgs<'createApplication()void'>,
        params: AppClientCallCoreParams &
          CoreAppCallArgs &
          AppClientCompilationParams &
          OnCompleteNoOp = {},
      ) {
        return {
          method: 'createApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        };
      },
    };
  }

  /**
   * Gets available update call factories
   */
  static get update() {
    return {
      /**
       * Constructs an update call for the AlgoDID smart contract using the updateApplication()void ABI method
       *
       * @param args Any args for the contract call
       * @param params Any additional parameters for the call
       * @returns A TypedCallParams object for the call
       */
      updateApplication(
        args: MethodArgs<'updateApplication()void'>,
        params: AppClientCallCoreParams & CoreAppCallArgs & AppClientCompilationParams = {},
      ) {
        return {
          method: 'updateApplication()void' as const,
          methodArgs: Array.isArray(args) ? args : [],
          ...params,
        };
      },
    };
  }

  /**
   * Constructs a no op call for the startUpload(address,uint64,uint64,pay)void ABI method
   *
   * Allocate boxes to begin data upload process
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static startUpload(
    args: MethodArgs<'startUpload(address,uint64,uint64,pay)void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs,
  ) {
    return {
      method: 'startUpload(address,uint64,uint64,pay)void' as const,
      methodArgs: Array.isArray(args)
        ? args
        : [args.pubKey, args.numBoxes, args.endBoxSize, args.mbrPayment],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the upload(address,uint64,uint64,byte[])void ABI method
   *
   * Upload data to a specific offset in a box
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static upload(
    args: MethodArgs<'upload(address,uint64,uint64,byte[])void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs,
  ) {
    return {
      method: 'upload(address,uint64,uint64,byte[])void' as const,
      methodArgs: Array.isArray(args) ? args : [args.pubKey, args.boxIndex, args.offset, args.data],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the finishUpload(address)void ABI method
   *
   * Mark uploading as false
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static finishUpload(
    args: MethodArgs<'finishUpload(address)void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs,
  ) {
    return {
      method: 'finishUpload(address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.pubKey],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the startDelete(address)void ABI method
   *
   * Starts the deletion process for the data associated with a DID
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static startDelete(
    args: MethodArgs<'startDelete(address)void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs,
  ) {
    return {
      method: 'startDelete(address)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.pubKey],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the deleteData(address,uint64)void ABI method
   *
   * Deletes a box of data
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static deleteData(
    args: MethodArgs<'deleteData(address,uint64)void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs,
  ) {
    return {
      method: 'deleteData(address,uint64)void' as const,
      methodArgs: Array.isArray(args) ? args : [args.pubKey, args.boxIndex],
      ...params,
    };
  }
  /**
   * Constructs a no op call for the dummy()void ABI method
   *
   * Dummy function to add extra box references for deleteData.
Boxes are 32k, but a single app call can only include enough references to read/write 8k
at a time. Thus when a box is deleted, we need to add additional dummy calls with box
references to increase the total read/write budget to 32k.
   *
   * @param args Any args for the contract call
   * @param params Any additional parameters for the call
   * @returns A TypedCallParams object for the call
   */
  static dummy(args: MethodArgs<'dummy()void'>, params: AppClientCallCoreParams & CoreAppCallArgs) {
    return {
      method: 'dummy()void' as const,
      methodArgs: Array.isArray(args) ? args : [],
      ...params,
    };
  }
}

/**
 * A client to make calls to the AlgoDID smart contract
 */
export class AlgoDidClient {
  /**
   * The underlying `ApplicationClient` for when you want to have more flexibility
   */
  public readonly appClient: ApplicationClient;

  private readonly sender: SendTransactionFrom | undefined;

  /**
   * Creates a new instance of `AlgoDidClient`
   *
   * @param appDetails appDetails The details to identify the app to deploy
   * @param algod An algod client instance
   */
  constructor(appDetails: AppDetails, private algod: Algodv2) {
    this.sender = appDetails.sender;
    this.appClient = algokit.getAppClient(
      {
        ...appDetails,
        app: APP_SPEC,
      },
      algod,
    );
  }

  /**
   * Checks for decode errors on the AppCallTransactionResult and maps the return value to the specified generic type
   *
   * @param result The AppCallTransactionResult to be mapped
   * @param returnValueFormatter An optional delegate to format the return value if required
   * @returns The smart contract response with an updated return value
   */
  protected mapReturnValue<
    TReturn,
    TResult extends AppCallTransactionResult = AppCallTransactionResult,
  >(
    result: AppCallTransactionResult,
    returnValueFormatter?: (value: any) => TReturn,
  ): AppCallTransactionResultOfType<TReturn> & TResult {
    if (result.return?.decodeError) {
      throw result.return.decodeError;
    }
    const returnValue =
      result.return?.returnValue !== undefined && returnValueFormatter !== undefined
        ? returnValueFormatter(result.return.returnValue)
        : (result.return?.returnValue as TReturn | undefined);
    return { ...result, return: returnValue } as AppCallTransactionResultOfType<TReturn> & TResult;
  }

  /**
   * Calls the ABI method with the matching signature using an onCompletion code of NO_OP
   *
   * @param typedCallParams An object containing the method signature, args, and any other relevant parameters
   * @param returnValueFormatter An optional delegate which when provided will be used to map non-undefined return values to the target type
   * @returns The result of the smart contract call
   */
  public async call<TSignature extends keyof AlgoDid['methods']>(
    typedCallParams: TypedCallParams<TSignature>,
    returnValueFormatter?: (value: any) => MethodReturn<TSignature>,
  ) {
    return this.mapReturnValue<MethodReturn<TSignature>>(
      await this.appClient.call(typedCallParams),
      returnValueFormatter,
    );
  }

  /**
   * Idempotently deploys the AlgoDID smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public deploy(
    params: AlgoDidDeployArgs & AppClientDeployCoreParams = {},
  ): ReturnType<ApplicationClient['deploy']> {
    const createArgs = params.createCall?.(AlgoDidCallFactory.create);
    const updateArgs = params.updateCall?.(AlgoDidCallFactory.update);
    return this.appClient.deploy({
      ...params,
      updateArgs,
      createArgs,
      createOnCompleteAction: createArgs?.onCompleteAction,
    });
  }

  /**
   * Gets available create methods
   */
  public get create() {
    const $this = this;
    return {
      /**
       * Creates a new instance of the AlgoDID smart contract using the createApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The create result
       */
      async createApplication(
        args: MethodArgs<'createApplication()void'>,
        params: AppClientCallCoreParams & AppClientCompilationParams & OnCompleteNoOp = {},
      ) {
        return $this.mapReturnValue<
          MethodReturn<'createApplication()void'>,
          AppCreateCallTransactionResult
        >(await $this.appClient.create(AlgoDidCallFactory.create.createApplication(args, params)));
      },
    };
  }

  /**
   * Gets available update methods
   */
  public get update() {
    const $this = this;
    return {
      /**
       * Updates an existing instance of the AlgoDID smart contract using the updateApplication()void ABI method.
       *
       * @param args The arguments for the smart contract call
       * @param params Any additional parameters for the call
       * @returns The update result
       */
      async updateApplication(
        args: MethodArgs<'updateApplication()void'>,
        params: AppClientCallCoreParams & AppClientCompilationParams = {},
      ) {
        return $this.mapReturnValue<
          MethodReturn<'updateApplication()void'>,
          AppUpdateCallTransactionResult
        >(await $this.appClient.update(AlgoDidCallFactory.update.updateApplication(args, params)));
      },
    };
  }

  /**
   * Makes a clear_state call to an existing instance of the AlgoDID smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The clear_state result
   */
  public clearState(args: BareCallArgs & AppClientCallCoreParams & CoreAppCallArgs = {}) {
    return this.appClient.clearState(args);
  }

  /**
   * Calls the startUpload(address,uint64,uint64,pay)void ABI method.
   *
   * Allocate boxes to begin data upload process
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public startUpload(
    args: MethodArgs<'startUpload(address,uint64,uint64,pay)void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(AlgoDidCallFactory.startUpload(args, params));
  }

  /**
   * Calls the upload(address,uint64,uint64,byte[])void ABI method.
   *
   * Upload data to a specific offset in a box
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public upload(
    args: MethodArgs<'upload(address,uint64,uint64,byte[])void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(AlgoDidCallFactory.upload(args, params));
  }

  /**
   * Calls the finishUpload(address)void ABI method.
   *
   * Mark uploading as false
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public finishUpload(
    args: MethodArgs<'finishUpload(address)void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(AlgoDidCallFactory.finishUpload(args, params));
  }

  /**
   * Calls the startDelete(address)void ABI method.
   *
   * Starts the deletion process for the data associated with a DID
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public startDelete(
    args: MethodArgs<'startDelete(address)void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(AlgoDidCallFactory.startDelete(args, params));
  }

  /**
   * Calls the deleteData(address,uint64)void ABI method.
   *
   * Deletes a box of data
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public deleteData(
    args: MethodArgs<'deleteData(address,uint64)void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(AlgoDidCallFactory.deleteData(args, params));
  }

  /**
   * Calls the dummy()void ABI method.
   *
   * Dummy function to add extra box references for deleteData.
Boxes are 32k, but a single app call can only include enough references to read/write 8k
at a time. Thus when a box is deleted, we need to add additional dummy calls with box
references to increase the total read/write budget to 32k.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The result of the call
   */
  public dummy(
    args: MethodArgs<'dummy()void'>,
    params: AppClientCallCoreParams & CoreAppCallArgs = {},
  ) {
    return this.call(AlgoDidCallFactory.dummy(args, params));
  }

  /**
   * Extracts a binary state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns A BinaryState instance containing the state value, or undefined if the key was not found
   */
  private static getBinaryState(state: AppState, key: string): BinaryState | undefined {
    const value = state[key];
    if (!value) return undefined;
    if (!('valueRaw' in value))
      throw new Error(
        `Failed to parse state value for ${key}; received an int when expected a byte array`,
      );
    return {
      asString(): string {
        return value.value;
      },
      asByteArray(): Uint8Array {
        return value.valueRaw;
      },
    };
  }

  /**
   * Extracts a integer state value out of an AppState dictionary
   *
   * @param state The state dictionary containing the state value
   * @param key The key of the state value
   * @returns An IntegerState instance containing the state value, or undefined if the key was not found
   */
  private static getIntegerState(state: AppState, key: string): IntegerState | undefined {
    const value = state[key];
    if (!value) return undefined;
    if ('valueRaw' in value)
      throw new Error(
        `Failed to parse state value for ${key}; received a byte array when expected a number`,
      );
    return {
      asBigInt() {
        return typeof value.value === 'bigint' ? value.value : BigInt(value.value);
      },
      asNumber(): number {
        return typeof value.value === 'bigint' ? Number(value.value) : value.value;
      },
    };
  }

  /**
   * Returns the smart contract's global state wrapped in a strongly typed accessor with options to format the stored value
   */
  public async getGlobalState(): Promise<AlgoDid['state']['global']> {
    const state = await this.appClient.getGlobalState();
    return {
      get currentIndex() {
        return AlgoDidClient.getIntegerState(state, 'currentIndex');
      },
    };
  }

  public compose(): AlgoDidComposer {
    const client = this;
    const atc = new AtomicTransactionComposer();
    let promiseChain: Promise<unknown> = Promise.resolve();
    const resultMappers: Array<undefined | ((x: any) => any)> = [];
    return {
      startUpload(
        args: MethodArgs<'startUpload(address,uint64,uint64,pay)void'>,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.startUpload(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      upload(
        args: MethodArgs<'upload(address,uint64,uint64,byte[])void'>,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.upload(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      finishUpload(
        args: MethodArgs<'finishUpload(address)void'>,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.finishUpload(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      startDelete(
        args: MethodArgs<'startDelete(address)void'>,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.startDelete(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      deleteData(
        args: MethodArgs<'deleteData(address,uint64)void'>,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.deleteData(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      dummy(
        args: MethodArgs<'dummy()void'>,
        params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
      ) {
        promiseChain = promiseChain.then(() =>
          client.dummy(args, {
            ...params,
            sendParams: { ...params?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      get update() {
        const $this = this;
        return {
          updateApplication(
            args: MethodArgs<'updateApplication()void'>,
            params?: AppClientComposeCallCoreParams & AppClientCompilationParams,
          ) {
            promiseChain = promiseChain.then(() =>
              client.update.updateApplication(args, {
                ...params,
                sendParams: { ...params?.sendParams, skipSending: true, atc },
              }),
            );
            resultMappers.push(undefined);
            return $this;
          },
        };
      },
      clearState(args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs) {
        promiseChain = promiseChain.then(() =>
          client.clearState({
            ...args,
            sendParams: { ...args?.sendParams, skipSending: true, atc },
          }),
        );
        resultMappers.push(undefined);
        return this;
      },
      addTransaction(
        txn:
          | TransactionWithSigner
          | TransactionToSign
          | Transaction
          | Promise<SendTransactionResult>,
        defaultSender?: SendTransactionFrom,
      ) {
        promiseChain = promiseChain.then(async () =>
          atc.addTransaction(
            await algokit.getTransactionWithSigner(txn, defaultSender ?? client.sender),
          ),
        );
        return this;
      },
      async atc() {
        await promiseChain;
        return atc;
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain;
        const result = await atc.simulate(
          client.algod,
          new modelsv2.SimulateRequest({ txnGroups: [], ...options }),
        );
        return {
          ...result,
          returns: result.methodResults?.map((val, i) =>
            resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue,
          ),
        };
      },
      async execute(sendParams?: AppClientComposeExecuteParams) {
        await promiseChain;
        const result = await algokit.sendAtomicTransactionComposer(
          { atc, sendParams },
          client.algod,
        );
        return {
          ...result,
          returns: result.returns?.map((val, i) =>
            resultMappers[i] !== undefined ? resultMappers[i]!(val.returnValue) : val.returnValue,
          ),
        };
      },
    } as unknown as AlgoDidComposer;
  }
}
export type AlgoDidComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the startUpload(address,uint64,uint64,pay)void ABI method.
   *
   * Allocate boxes to begin data upload process
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  startUpload(
    args: MethodArgs<'startUpload(address,uint64,uint64,pay)void'>,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
  ): AlgoDidComposer<[...TReturns, MethodReturn<'startUpload(address,uint64,uint64,pay)void'>]>;

  /**
   * Calls the upload(address,uint64,uint64,byte[])void ABI method.
   *
   * Upload data to a specific offset in a box
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  upload(
    args: MethodArgs<'upload(address,uint64,uint64,byte[])void'>,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
  ): AlgoDidComposer<[...TReturns, MethodReturn<'upload(address,uint64,uint64,byte[])void'>]>;

  /**
   * Calls the finishUpload(address)void ABI method.
   *
   * Mark uploading as false
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  finishUpload(
    args: MethodArgs<'finishUpload(address)void'>,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
  ): AlgoDidComposer<[...TReturns, MethodReturn<'finishUpload(address)void'>]>;

  /**
   * Calls the startDelete(address)void ABI method.
   *
   * Starts the deletion process for the data associated with a DID
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  startDelete(
    args: MethodArgs<'startDelete(address)void'>,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
  ): AlgoDidComposer<[...TReturns, MethodReturn<'startDelete(address)void'>]>;

  /**
   * Calls the deleteData(address,uint64)void ABI method.
   *
   * Deletes a box of data
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  deleteData(
    args: MethodArgs<'deleteData(address,uint64)void'>,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
  ): AlgoDidComposer<[...TReturns, MethodReturn<'deleteData(address,uint64)void'>]>;

  /**
   * Calls the dummy()void ABI method.
   *
   * Dummy function to add extra box references for deleteData.
Boxes are 32k, but a single app call can only include enough references to read/write 8k
at a time. Thus when a box is deleted, we need to add additional dummy calls with box
references to increase the total read/write budget to 32k.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  dummy(
    args: MethodArgs<'dummy()void'>,
    params?: AppClientComposeCallCoreParams & CoreAppCallArgs,
  ): AlgoDidComposer<[...TReturns, MethodReturn<'dummy()void'>]>;

  /**
   * Gets available update methods
   */
  readonly update: {
    /**
     * Updates an existing instance of the AlgoDID smart contract using the updateApplication()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    updateApplication(
      args: MethodArgs<'updateApplication()void'>,
      params?: AppClientComposeCallCoreParams & AppClientCompilationParams,
    ): AlgoDidComposer<[...TReturns, MethodReturn<'updateApplication()void'>]>;
  };

  /**
   * Makes a clear_state call to an existing instance of the AlgoDID smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(
    args?: BareCallArgs & AppClientComposeCallCoreParams & CoreAppCallArgs,
  ): AlgoDidComposer<[...TReturns, undefined]>;

  /**
   * Adds a transaction to the composer
   *
   * @param txn One of: A TransactionWithSigner object (returned as is), a TransactionToSign object (signer is obtained from the signer property), a Transaction object (signer is extracted from the defaultSender parameter), an async SendTransactionResult returned by one of algokit utils helpers (signer is obtained from the defaultSender parameter)
   * @param defaultSender The default sender to be used to obtain a signer where the object provided to the transaction parameter does not include a signer.
   */
  addTransaction(
    txn: TransactionWithSigner | TransactionToSign | Transaction | Promise<SendTransactionResult>,
    defaultSender?: SendTransactionFrom,
  ): AlgoDidComposer<TReturns>;
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  atc(): Promise<AtomicTransactionComposer>;
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(options?: SimulateOptions): Promise<AlgoDidComposerSimulateResult<TReturns>>;
  /**
   * Executes the transaction group and returns the results
   */
  execute(sendParams?: AppClientComposeExecuteParams): Promise<AlgoDidComposerResults<TReturns>>;
};
export type SimulateOptions = Omit<
  ConstructorParameters<typeof modelsv2.SimulateRequest>[0],
  'txnGroups'
>;
export type AlgoDidComposerSimulateResult<TReturns extends [...any[]]> = {
  returns: TReturns;
  methodResults: ABIResult[];
  simulateResponse: modelsv2.SimulateResponse;
};
export type AlgoDidComposerResults<TReturns extends [...any[]]> = {
  returns: TReturns;
  groupId: string;
  txIds: string[];
  transactions: Transaction[];
};
